<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C语言基础知识</title>
      <link href="/2024/04/20/04-c-yu-yan/c-yu-yan-ji-chu-zhi-shi/"/>
      <url>/2024/04/20/04-c-yu-yan/c-yu-yan-ji-chu-zhi-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="第01章-C语言入门"><a href="#第01章-C语言入门" class="headerlink" title="第01章_C语言入门"></a>第01章_C语言入门</h1><h2 id="本章专题脉络"><a href="#本章专题脉络" class="headerlink" title="本章专题脉络"></a>本章专题脉络</h2><img src="./images/第1章_C语言入门.png" alt="第1章_C语言入门" style="zoom: 40%;"><h2 id="1、初识计算机语言"><a href="#1、初识计算机语言" class="headerlink" title="1、初识计算机语言"></a>1、初识计算机语言</h2><h3 id="1-1-计算机语言是什么"><a href="#1-1-计算机语言是什么" class="headerlink" title="1.1 计算机语言是什么"></a>1.1 计算机语言是什么</h3><ul><li><p><strong>人类语言</strong>：是人与人之间用于沟通的一种方式。例如：中国人与中国人用普通话沟通。而中国人要和英国人交流，可以使用普通话或英语。</p></li><li><p><strong>计算机编程语言</strong>，就是人与计算机交流的方式。人们可以使用<code>编程语言</code>对计算机下达<code>命令</code>，让计算机完成人们需要的功能。</p><ul><li>计算机语言有很多种。如：C 、C++、Java、Go、JavaScript、Python，Scala等。</li></ul></li></ul><blockquote><p>体会：语言 = 语法 + 逻辑</p></blockquote><h3 id="1-2-计算机语言简史"><a href="#1-2-计算机语言简史" class="headerlink" title="1.2 计算机语言简史"></a>1.2 计算机语言简史</h3><ul><li><p><strong>第一代：机器语言（相当于人类的石器时代）</strong></p><ul><li><p>1946年2月14日，世界上第一台计算机<code>ENAC</code>诞生，使用的是最原始的<code>穿孔卡片</code>。这种卡片上使用的是用<code>二进制代码</code>表示的语言，与人类语言差别极大，这种语言就称为<code>机器语言</code>。比如一段典型的机器码：</p><pre class="line-numbers language-none"><code class="language-none">1.0000,0000,000000010000 代表 LOAD A, 162.0000,0001,000000000001 代表 LOAD B, 13.0001,0001,000000010000 代表 STORE B, 16<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>这种语言本质上是计算机能识别的<code>唯一语言</code>，人类很难理解。可以大胆想象”<code>此时的程序员99.9%都是异类！</code>“</p><p><img src="/images/image-20220309223406537.png" alt="image-20220309223406537"></p></li></ul></li><li><p><strong>第二代：汇编语言（相当于人类的青铜&amp;铁器时代）</strong></p><ul><li><p>使用英文缩写的<code>助记符</code>来表示基本的操作，这些助记符构成了汇编语言的基础。比如：<code>LOAD</code>、<code>MOVE</code>等，使人更容易使用。因此，汇编语言也称为<code>符号语言</code>。</p></li><li><p>优点：能编写<code>高效率</code>的程序。</p></li><li><p>缺点：汇编语言是<code>面向机器的</code>，不同计算机会有不同的汇编语言，程序不易移植。</p><p><img src="/images/1689152350231.png" alt="1689152350231"></p></li><li><p>目前仍然应用于工业电子编程领域、软件的加密解密、计算机病毒分析等。</p></li></ul></li><li><p><strong>第三代：高级语言（相当于人类的信息时代）</strong></p><ul><li><p>高级语言，是一种<code>接近于人们使用习惯</code>的程序设计语言。它允许程序员使用<code>接近日常英语</code>的指令来编写程序，程序中的符号和算式也与<code>日常用的数学式子</code>差不多，接近于自然语言和数学语言，容易为人们掌握。比如：</p><p><img src="/images/1689152910950.png" alt="1689152910950"></p></li><li><p>高级语言<code>独立于计算机硬件</code>，有一定的通用性；计算机不能直接识别和执行用高级语言编写的程序，需要使用<strong>编译器或者解释器</strong>，<code>转换为机器语言</code>才能被识别和执行。</p><p><img src="/images/1689153225780.png" alt="1689153225780"></p></li><li><p>使用普遍的高级语言有Fortran、ALGOL、Basic、COBOL、LISP、Pascal、PROLOG、C、C++、VC、VB、Delphi、Java等。</p></li></ul></li></ul><h2 id="2、初识C语言"><a href="#2、初识C语言" class="headerlink" title="2、初识C语言"></a>2、初识C语言</h2><h3 id="2-1-C语言的由来"><a href="#2-1-C语言的由来" class="headerlink" title="2.1 C语言的由来"></a>2.1 C语言的由来</h3><p><strong>C 语言最初是作为 Unix 系统的开发工具而发明的。</strong></p><p>1969年，美国贝尔实验室的肯·汤普森（Ken Thompson）与丹尼斯·里奇（Dennis Ritchie）一起开发了Unix 操作系统。Unix 是用<code>汇编语言</code>写的，依赖于计算机硬件。为了程序的<code>可读性</code>和<code>可移植性</code>，他们决定使用高级语言重写。但是，当时的高级语言无法满足他们的要求，汤普森就在 BCPL 语言的基础上发明了 <code>B 语言</code>。</p><p>1972年，丹尼斯·里奇（Dennis Ritchie）在 B 语言的基础上重新设计了一种新语言，这种新语言取代了 B 语言，称为<code> C 语言</code>。</p><p>1973年，<code>整个 Unix 系统都使用 C 语言重写</code>。</p><p><img src="/images/image-20230821142911092.png" alt="image-20230821142911092"></p><p>此后，这种语言快速流传，广泛用于各种操作系统和系统软件的开发。如UNIX、MS-DOS、Microsoft Windows及Linux等。</p><p><img src="/images/image-20230808143350533.png" alt="image-20230808143350533"></p><p>1988年，美国国家标准协会（ANSI）正式将<code> C语言标准化</code>，标志着 C 语言开始稳定和规范化。</p><h3 id="2-2-为什么要学习C语言"><a href="#2-2-为什么要学习C语言" class="headerlink" title="2.2 为什么要学习C语言"></a>2.2 为什么要学习C语言</h3><p>1、<strong>C语言具有可移植性好、跨平台的特点</strong>，用C编写的代码可以在不同的操作系统和硬件平台上编译和运行。</p><ul><li>C 语言的原始设计目的，是将 Unix 系统移植到其他计算机架构，这使得它从一开始就非常注重可移植性。</li></ul><p>2、<strong>C语言在许多领域应用广泛。</strong>掌握C语言可以让你有更多就业机会。</p><ul><li><code>操作系统</code>：C 广泛用于开发操作系统，如 Unix、Linux 和 Windows。</li><li><code>嵌入式系统</code>：C 是一种用于开发嵌入式系统（如微控制器、微处理器和其他电子设备）的流行语言。</li><li><code>系统软件</code>：C用于开发设备驱动程序、编译器和汇编器等系统软件。</li><li><code>网络</code>：C 语言广泛用于开发网络应用程序，例如 Web 服务器、网络协议和网络驱动程序。</li><li><code>数据库系统</code>：C 用于开发数据库系统，例如 Oracle、MySQL 和 PostgreSQL。</li><li><code>游戏</code>：由于 C 能够处理低级硬件交互，因此经常用于开发计算机游戏。</li><li><code>人工智能</code>：C 用于开发人工智能和机器学习应用程序，例如神经网络和深度学习算法。</li><li><code>科学应用</code>：C 用于开发科学应用程序，例如仿真软件和数值分析工具。</li><li><code>金融应用</code>：C用于开发股票市场分析和交易系统等金融应用。</li></ul><p>3、C 语言能够直接对硬件进行操作、管理内存、跟操作系统对话，这使得它是一种非常接近底层的语言，非常适合写需要<strong>跟硬件交互、有极高性能要求的程序</strong>。</p><p>4、<strong>学习C语言有助于快速上手其他编程语言</strong>，比如C++（原先是C语言的一个扩展，在C语言的基础上嫁接了面向对象编程）、C#、Java、PHP、Javascript、Perl等。这些语言都继承或深受C语言的影响和启发。</p><p>5、C 语言长盛不衰。至今，<strong>依然是最广泛使用、最流行的编程语言之一</strong>。包括很多大学将C语言作为计算机教学的入门语言，拥有庞大而活跃的用户社区，这意味着有许多资源和库可供开发人员使用。</p><h3 id="2-3-计算机语言排行榜"><a href="#2-3-计算机语言排行榜" class="headerlink" title="2.3 计算机语言排行榜"></a>2.3 计算机语言排行榜</h3><p>TIOBE （<a href="https://www.tiobe.com/tiobe-index/%EF%BC%89%E6%98%AF%E4%B8%80%E4%B8%AA%E6%B5%81%E8%A1%8C%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E6%8E%92%E8%A1%8C%EF%BC%8C%E6%AF%8F%E6%9C%88%E6%9B%B4%E6%96%B0%E3%80%82%E6%8E%92%E5%90%8D%E6%9D%83%E9%87%8D%E5%9F%BA%E4%BA%8E%E4%B8%96%E7%95%8C%E8%8C%83%E5%9B%B4%E5%86%85">https://www.tiobe.com/tiobe-index/）是一个流行编程语言排行，每月更新。排名权重基于世界范围内</a> 工程师数量，Google、Bing、Yahoo! 、Wikipedia、Amazon、Youtube和百度这些主流的搜索引擎，也将作为排名权重的参考指标。</p><p><img src="/images/image-20230821142412443.png" alt="image-20230821142412443"></p><p>计算机走势图：</p><p><img src="/images/image-20230821142441945.png" alt="image-20230821142441945"></p><h3 id="2-4-网友一言话C"><a href="#2-4-网友一言话C" class="headerlink" title="2.4 网友一言话C"></a>2.4 网友一言话C</h3><p><a href="https://www.nowcoder.com/stack/209">https://www.nowcoder.com/stack/209</a></p><p><img src="/images/image-20230819162927908.png" alt="image-20230819162927908"></p><h3 id="2-5-C语言的版本选择"><a href="#2-5-C语言的版本选择" class="headerlink" title="2.5 C语言的版本选择"></a>2.5 C语言的版本选择</h3><p>随着微型计算机的日益普及，出现了许多C语言版本。</p><p><strong>版本1：K＆R C</strong></p><p>K&amp;R C 指的是 C 语言的原始版本。1978年，C 语言的发明者布莱恩·柯林（Brian Kernighan）和丹尼斯·里奇（Dennis Ritchie）合写了一本著名的教材《C 编程语言》（The C programming language）。</p><p>由于 C 语言还没有成文的语法标准，这本书就成了公认标准，以两位作者的姓氏首字母作为版本简称“K&amp;R C”。</p><p><strong>版本2：ANSI C（又称 C89 或 C90）</strong></p><p>C 语言的原始版本非常简单，对很多情况的描述非常模糊，加上 C 语法依然在快速发展，要求将 C 语言标准化的呼声越来越高。</p><p>1989年，美国国家标准协会（ANSI）制定了一套 C 语言标准，并于次年被国际标准化组织（ISO）通过。它被称为“ANSI C”，也可以按照发布年份，称为“C89 或 C90”。</p><p><strong>版本3：C99</strong></p><p>C 语言标准的第一次<code>大型修订</code>，发生在1999年，增加了许多语言特性，比如双斜杠（ // ）的注释语法，可变长度数组、灵活的数组成员、复数、内联函数和指定的初始值设定项。这个版本称为 C99，<code>是目前最流行的 C 版本</code>。</p><p><strong>版本4：C11</strong></p><p>2011年，标准化组织再一次对C 语言进行修订，增加了_Generic、static_assert 和原子类型限定符。这个版本称为C11。</p><blockquote><p>需要强调的是，修订标准的原因不是因为原标准不能用，而是需要跟进新的技术。</p></blockquote><p><strong>版本5：C17</strong></p><p>C11 标准在2017年进行了修补，但发布是在2018年。新版本只是解决了 C11 的一些缺陷，没有引入任何新功能。这个版本称为 C17。</p><p><strong>版本6：C23</strong></p><p>2023年预计发布，计划进一步增强安全性，消除实现定义的行为，引入模块化语言概念等新特性，使C语言在安全和可靠性方面有重大提高。</p><h2 id="3、第一个C程序的编写-gt-编译-gt-运行"><a href="#3、第一个C程序的编写-gt-编译-gt-运行" class="headerlink" title="3、第一个C程序的编写->编译->运行"></a>3、第一个C程序的编写-&gt;编译-&gt;运行</h2><h3 id="3-1-步骤1：HelloWorld的编写"><a href="#3-1-步骤1：HelloWorld的编写" class="headerlink" title="3.1 步骤1：HelloWorld的编写"></a>3.1 步骤1：HelloWorld的编写</h3><p>C 语言的源代码文件，以<strong>后缀名 .c 结尾</strong>。下面是一个简单的 C 程序 <code>Hello.c</code> 。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span>              </span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                  <span class="token punctuation">{</span>                                   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello,world!!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>                   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-步骤2：编译器的安装与配置"><a href="#3-2-步骤2：编译器的安装与配置" class="headerlink" title="3.2 步骤2：编译器的安装与配置"></a>3.2 步骤2：编译器的安装与配置</h3><p>C 语言是一种<code>编译型语言</code>，源码都是<code>文本文件</code>，本身无法执行。必须通过编译器，生成二进制的可执行文件，才能执行。</p><p>目前，最常见的 C 语言编译器是自由软件基金会推出的 <code>GCC 编译器</code>，可以免费使用。Linux 和 Mac 系统可以直接安装 GCC，Windows 系统可以安装 <code>MinGW</code>。</p><blockquote><p>补充知识：MinGW和GCC的区别：</p><p>GCC是一个跨平台的编译器集合，可用于多种操作系统和处理器架构，包括Windows；而MinGW是GCC在Windows平台上的移植版本，主要用于在Windows上本地编译C和C++代码。</p></blockquote><p>在Windows下，MinGW的详细安装和配置见<code>《第01章附录：MinGW编译器的安装和配置.md》</code>。</p><h3 id="3-3-步骤3：编译和运行"><a href="#3-3-步骤3：编译和运行" class="headerlink" title="3.3 步骤3：编译和运行"></a>3.3 步骤3：编译和运行</h3><p>编译器将代码从文本翻译成二进制指令的过程，就称为编译阶段，又称为“编译时”（compile time），跟运行阶段（又称为“运行时”）相区分。</p><p>假设你已经安装好了 GCC 编译器，可以通过<code>win+r</code>打开cmd命令行，在Hello.c文件所在目录下执行下面的命令。</p><pre class="line-numbers language-none"><code class="language-none">&gt; gcc Hello.c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image-20230821203629981.png" alt="image-20230821203629981"></p><p>上面命令使用 gcc 编译器，将源文件 Hello.c 编译成二进制代码。</p><p>运行这个命令以后，默认会在当前目录下生成一个编译产物文件 a.exe。执行该文件，就会在屏幕上输出 Hello World 。</p><pre class="line-numbers language-none"><code class="language-none">&gt; a.exehello,world!!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/images/image-20230821203807040.png" alt="image-20230821203807040"></p><p><strong>GCC 的 -o 参数（output 的缩写）可以指定编译产物的文件名。</strong></p><pre class="line-numbers language-none"><code class="language-none">&gt; gcc -o Hello Hello.c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="images/image-20230821204057346.png" alt="image-20230821204057346" style="zoom:80%;"><p>上面命令的 <code>-o Hello</code> 指定，编译得到的可执行文件名为 Hello.exe ，取代默认的 a.exe。执行该文件，也会得到同样的结果。</p><pre class="line-numbers language-none"><code class="language-none">&gt; Hello.exehello,world!!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/images/image-20230821204306119.png" alt="image-20230821204306119"></p><p><strong>GCC 的 <code>-std= 参数</code>（standard 的缩写）还可以指定按照哪个 C 语言的标准进行编译。</strong></p><pre class="line-numbers language-none"><code class="language-none">&gt; gcc -std=c99 Hello.c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面命令指定按照 C99 标准进行编译。</p><h2 id="4、IDE的使用"><a href="#4、IDE的使用" class="headerlink" title="4、IDE的使用"></a>4、IDE的使用</h2><p>IDE(Integrated Development Environment，集成开发环境)：相较于文本开发工具，IDE可以把代码编写，编译，执行，调试等多种功能综合到一起的开发工具。</p><h3 id="4-1-开发工具介绍"><a href="#4-1-开发工具介绍" class="headerlink" title="4.1 开发工具介绍"></a>4.1 开发工具介绍</h3><h4 id="方式1：本地安装的IDE工具"><a href="#方式1：本地安装的IDE工具" class="headerlink" title="方式1：本地安装的IDE工具"></a>方式1：本地安装的IDE工具</h4><p><strong>1. Code::Block</strong></p><p>Code::Block是一个免费的跨平台IDE，它支持C、C++和Fortan程序的开发。Code::Block的最大特点是它支持通过插件的方式对IDE自身功能进行扩展，这使得Code::Block具有很强的灵活性，方便用户使用。</p><p>官网地址：<a href="https://www.codeblocks.org/">https://www.codeblocks.org</a></p><p><strong>2. Microsoft Visual C++ 2010</strong></p><p>Visual C++ 2010，简称VC2010，是由微软开发的独立的、免费的 C/C++ 编译工具，与Visual Basic等并列，最后微软将它们整合在一起组成了Visual Studio。</p><p>Visual C++从发布起到现在已经有10个大版本了，这里介绍的Visual C++ 2010就是Visual C++ 10，简称VC10。上朔10多年发布的Visual C++ 6.0，被称为史上最经典的VC，现在有很多企业还在用它，大量的教材基于这个版本的VC来写的。但VC6比较弱，被淘汰是迟早的。</p><p><strong>3. Microsoft Visual Studio</strong></p><p>Visual Studio（简称 VS）是由微软公司发布的集成开发环境。它包括了整个软件生命周期中所需要的大部分工具，如UML工具、代码管控工具、集成开发环境（IDE）等。</p><p>Visual Studio 支持 C/C++、C#、F#、VB 等多种程序语言的开发和测试，可以用于生成Web应用程序，也可以生成桌面应用程序，功能十分强大。但下载和安装很可能耗时数小时，还可能会塞满磁盘。</p><p>Visual Studio 2019有三种版本：社区版(免费，不支持企业使用)，专业版(第一年1199美元/ 799美元续订)和企业版(第一年5999美元/2569美元续订)。企业版拥有面向架构师的功能、高级调试和测试，这些功能是另两种SKU所没有的。</p><p>Visual Studio旨在成为世界上最好的IDE（集成开发环境），目前最新版本为 Visual Studio 2023。</p><blockquote><p>这就好像Office 2007是由Word 2007、Excel 2007、Access 2007等等组成的一个道理。其中Visual C++就是Visual Studio的一个重要的组成部分。</p></blockquote><p>官网地址：<a href="https://visualstudio.microsoft.com/">https://visualstudio.microsoft.com</a></p><p><strong>4. CLion</strong></p><p>CLion是一款由JetBrains推出的跨平台C/C++集成开发环境（IDE），它具有智能编辑器、CMake构建支持、调试器、单元测试、代码分析等功能,可以极大提高C/C++开发效率。</p><p>官网地址：<a href="https://www.jetbrains.com/clion">https://www.jetbrains.com/clion</a></p><h4 id="方式2：可在线使用的工具"><a href="#方式2：可在线使用的工具" class="headerlink" title="方式2：可在线使用的工具"></a>方式2：可在线使用的工具</h4><p>CodingGround: <a href="https://tutorialspoint.com/compile_c_online.php">https://tutorialspoint.com/compile_c_online.php</a></p><p><img src="/images/image-20230821153059391.png" alt="image-20230821153059391"></p><p>OnlineGDB: <a href="https://onlinegdb.com/online_c_compiler">https://onlinegdb.com/online_c_compiler</a></p><p><img src="/images/image-20230821153146970.png" alt="image-20230821153146970"></p><p>Lightly：<a href="https://cde2f3ce.lightly.teamcode.com/">https://cde2f3ce.lightly.teamcode.com/</a></p><p><img src="/images/image-20230821153237900.png" alt="image-20230821153237900"></p><h3 id="4-2-CLion的下载与安装"><a href="#4-2-CLion的下载与安装" class="headerlink" title="4.2 CLion的下载与安装"></a>4.2 CLion的下载与安装</h3><p>详细见<code>《第01章附录：C开发利器：CLion的使用.md》</code>。</p><h3 id="4-3-CLion中HelloWorld的执行"><a href="#4-3-CLion中HelloWorld的执行" class="headerlink" title="4.3 CLion中HelloWorld的执行"></a>4.3 CLion中HelloWorld的执行</h3><p>1）选择”New Project”：</p><img src="images/1692686679397.png" alt="1692686679397" style="zoom:80%;"><p>2）指定创建C可执行文件、工程目录，图中的“untitled1”需要修改为自己的工程名称。如下所示：</p><img src="images/1692687949240.png" alt="1692687949240" style="zoom:80%;"><p>3）选择C可执行文件，修改工程名称为demo1</p><img src="images/1692687854607.png" alt="1692687854607" style="zoom:80%;"><p>4）点击“Create”进行下一步，如图所示</p><img src="images/1692688033686.png" alt="1692688033686" style="zoom:80%;"><p>5）此处选择编译器，默认MinGW即可，点击“OK”按钮，如图所示，默认创建了main.c文件。</p><img src="images/1692688090496.png" alt="1692688090496" style="zoom:60%;"><p>6）点击执行按钮，如下所示</p><img src="images/1692688278731.png" alt="1692688278731" style="zoom: 60%;"><h3 id="4-4-C-程序运行机制"><a href="#4-4-C-程序运行机制" class="headerlink" title="4.4 C 程序运行机制"></a>4.4 C 程序运行机制</h3><p><strong>过程1：编辑</strong></p><p>编写C语言源程序代码，并以文件的形式存储到磁盘中。源程序文件以“<code>.c</code>”作为扩展名。</p><p><strong>过程2：编译</strong></p><p>将C语言源程序转换为<code>目标程序(或目标文件)</code>。如果程序没有错误，没有任何提示，就会生成一个扩展名为“<code>.obj</code>”的二进制文件。C语言中的每条可执行语句经过编译后最终都将被转换成二进制的机器指令。</p><p><strong>过程3：链接/连接</strong></p><p>将编译形成的目标文件“.obj”和库函数及其他目录文件连接/链接，形成统一的<code>可执行的</code>二进制文件“<code>.exe</code>”。</p><blockquote><p>为什么需要链接库文件呢？</p><p>因为我们的C程序中会使用 C程序库的内容，比如&lt;stdio.h&gt; 、&lt;stdlib.h&gt; 中的函数printf()、system()等，这些函数不是程序员自己写的，而是C程序库中提供的，因此需要链接。链接后，生成的.exe 文件，比obj 文件大了很多。</p></blockquote><p><strong>过程4：运行</strong></p><p>有了可执行的exe文件，我们可以在控制台下直接运行此exe文件。</p><p><img src="/images/image-20230810153413126.png" alt="image-20230810153413126"></p><blockquote><p>注意：</p><p>对修改后的xxx.c源文件需要<strong>重新编译、链接</strong>，生成新的exe文件后，再执行，才能生效。</p></blockquote><p>练习：</p><blockquote><p>计算机高级语言程序的运行方法有编译执行和解释执行两种，以下叙述中正确的是（　　）。<br>A．C语言程序仅可以编译执行<br>B．C语言程序仅可以解释执行<br>C．C语言程序既可以编译执行，又可以解释执行<br>D．以上说法都不对</p><p>【答案】A</p><p>【解析】编译执行是指程序执行前需要一个专门的编译过程把程序编译成机器语言的文件，再次运行时不需要重新翻译，执行效率高；解释执行是指每个语句都是执行的时候才翻译，执行效率低。用C语言编写的程序必须经过编译器编译后，转换为二进制的机器指令来运行。</p></blockquote><p>练习：</p><blockquote><p>以下叙述中错误的是（　　）。<br>A．C语言的可执行程序是由一系列机器指令构成的<br>B．用C语言编写的源程序不能直接在计算机上运行<br>C．通过编译得到的二进制目标程序需要链接才可以运行<br>D．在没有安装C语言集成开发环境的机器上不能运行C源程序生成的exe文件</p><p>【答案】D</p><p>【解析】A项正确，C语言的可执行程序是由一系列机器指令组成的；BC项正确，用C语言编写的源程序必须经过编译，生成二进制目标代码，再经过连接才能运行；D项错误，C语言经过编译链接后的二进制目标代码可以脱离C语言集成开发环境独立运行。答案选择D选项。</p></blockquote><h2 id="5、注-释-comment"><a href="#5、注-释-comment" class="headerlink" title="5、注 释(comment)"></a>5、注 释(comment)</h2><img src="images/image-20220610113151774.png" alt="image-20220610113151774" style="zoom: 67%;"><ul><li><p>什么是注释？</p><ul><li>源文件中用于<code>解释</code>、<code>说明</code>程序的文字就是注释。</li><li>注释只是给人看的，程序执行时，<code>编译器会忽略注释</code>，注释对代码执行没有影响</li></ul></li><li><p>注释是一个程序员必须要具有的良好编程习惯。实际开发中，程序员可以先将自己的<code>思想</code>通过注释整理出来，再用<code>代码</code>去体现。</p><blockquote><p>程序员最讨厌两件事：</p><ul><li><p>一件是自己写代码被要求加注释</p></li><li><p>另一件是接手别人代码，发现没有注释</p></li></ul></blockquote></li><li><p>不加注释的危害</p><p><img src="/images/%E6%96%B0%E6%9D%A5%E7%9A%84%E8%8F%9C%E9%B8%9F%E7%A8%8B%E5%BA%8F%E5%91%98%E9%97%AF%E7%A5%B8%E4%BA%86%E3%80%82%E3%80%82%E3%80%82%E8%BF%99%E6%AE%B5%E4%BB%A3%E7%A0%81%E5%A5%BD%E5%A4%9A%E5%B9%B4%E9%83%BD%E6%B2%A1%E4%BA%BA%E6%95%A2%E5%8A%A8%E8%BF%87%E7%9A%84.gif"></p></li><li><p>C语言中的注释类型：</p><ul><li><strong>单行注释</strong></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 单行注释</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>多行注释(或块注释)</strong></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*  这是第一行注释  这是第二行注释  这是第三行注释*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 我是被注释的文字 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>举例</p><ul><li>举例1</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span>              <span class="token comment">//这是编译预处理指令</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                  <span class="token comment">//定义主函数</span><span class="token punctuation">{</span>                               <span class="token comment">//函数开始的标志</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello World\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//输出所指定的一行信息</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>                   <span class="token comment">//函数执行完毕时返回函数值0</span><span class="token punctuation">}</span>                               <span class="token comment">//函数结束的标志</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>举例2</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 这里定义了一个变量</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>举例3</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* printf("2");printf("3");  */</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"4"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>举例4</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> s <span class="token comment">/* file name */</span><span class="token punctuation">,</span> <span class="token keyword">int</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>注意：</p><ol><li><p>多行注释不能嵌套使用</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*我是注释信息1/*我是注释信息2*/</span>我是注释信息<span class="token number">3</span><span class="token operator">*</span><span class="token operator">/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>双引号内使用注释，会被当做普通字符串看待，失去注释作用</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"// hello /* atguigu */ "</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol></li><li><p>一个段子</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">A：嘿 <span class="token comment">//是什么意思啊？</span>B：嘿<span class="token punctuation">.</span>A：呃 我问你<span class="token comment">//是什么意思？</span>B：问吧<span class="token punctuation">.</span>A：我刚才不是问了么？B：啊？A：你再看看记录<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>B：看完了<span class="token punctuation">.</span>A：<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>所以<span class="token comment">//是啥？</span>B：所以什么？A：你存心耍我呢吧？B：没有啊 你想问什么？……不断循环之后，A一气之下和B绝交，自己苦学程序。N年之后，A终于修成正果，回想起B，又把聊天记录翻出来看，这时，他突然发现B没有耍他……而他自己也不知道当年他问B的究竟是什么问题……<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>练习：</p><blockquote><p>以下叙述中错误的是（　　）。<br>A．C语言中的每条可执行语句和非执行语句最终都将被转换成二进制的机器指令<br>B．C程序经过编译、链接步骤之后才能形成一个真正可执行的二进制机器指令文件<br>C．用C语言编写的程序称为源程序，它以ASCII代码形式存放在一个文本文件中<br>D．C语言源程序经编译后生成后缀为.obj的目标程序</p><p>【答案】A</p><p>【解析】A项错误，注释语句不会被翻译成二进制的机器指令。C源程序经过C编译程序编译之后生成后缀为.obj的二进制文件（称为目标文件），然后由“链接程序”（Link）的软件把.obj文件与各种库函数连接起来生成一个后缀为.exe的可执行文件。答案选择A选项。</p></blockquote><h2 id="6、HelloWorld的剖析"><a href="#6、HelloWorld的剖析" class="headerlink" title="6、HelloWorld的剖析"></a>6、HelloWorld的剖析</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span>              </span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                  <span class="token punctuation">{</span>                                   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello World\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>                   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-1-规范的代码风格"><a href="#6-1-规范的代码风格" class="headerlink" title="6.1 规范的代码风格"></a>6.1 规范的代码风格</h3><p><strong>正确的缩进和空白</strong></p><ol><li><p>使用一次tab操作，实现缩进，默认整体向右边移动。相反，使用shift+tab整体向左移</p></li><li><p>运算符两边习惯性各加一个空格。比如：<code>2 + 4 * 5</code>。</p></li><li><p>可以使用代码格式化快捷键 ctrl+alt+L。(在CLion中使用)</p></li></ol><p><strong>代码块的风格</strong></p><p>1）行尾风格</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                                          <span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">&gt;</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> a<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span><span class="token punctuation">{</span><span class="token keyword">return</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>                   <span class="token punctuation">}</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2）次行风格</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                                          <span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">&gt;</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> a<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token keyword">return</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>                   <span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>正确的注释和注释风格：</strong></p><p>1）如果注释一个函数，可以使用多行注释(或块注释)。</p><p>2）如果注释函数中的某一行语句，可以使用单行注释。</p><h3 id="6-2-代码细节剖析"><a href="#6-2-代码细节剖析" class="headerlink" title="6.2 代码细节剖析"></a>6.2 代码细节剖析</h3><h4 id="①-main"><a href="#①-main" class="headerlink" title="① main()"></a>① main()</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>每一个程序(或工程)可以定义很多函数(后面讲)，但有且只有一个main()函数，作为程序执行的入口，在 main()函数结尾结束整个程序的运行。</li><li>空括号()，表示 main 不接受任何参数。</li><li>写在main之前的“int”称为关键字，代表数据类型是整型。它是main()的返回值类型。即在执行main()函数后会得到一个整型值(即函数值)。</li><li>C 语言约定： <code>return 0</code>，表示main()函数终止运行，且运行成功；如果返回其它非零整数，就表示运行失败。默认情况下，如果 main() 里面省略 <code>return 0</code> 这一行，编译器会自动加上，但是为了保持统一的代码风格，不建议省略。</li></ul><h4 id="②-函数体"><a href="#②-函数体" class="headerlink" title="② 函数体"></a>② 函数体</h4><ul><li><p>一对花括号{}定义了函数的主体，所有函数都必须以大括号开头和结尾，成对出现。</p></li><li><p>C 程序中的函数体指的是作为该函数一部分的语句。它可以是任何操作，比如搜索、排序、打印等。</p></li><li><p>每一个执行语句后面都会有一个英文分号“;”作为语句结束的标志。</p></li><li><p>一行内可写几条语句，一条语句也可写在几行上。</p></li></ul><h4 id="③-printf"><a href="#③-printf" class="headerlink" title="③ printf()"></a>③ printf()</h4><p>printf()函数是产生格式化输出的函数，作用是将参数文本输出到屏幕。它名字里面的 f 代表 format (格式化)，表示可以指定输出文本的格式。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello World"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//将字符串输出到控制台，行尾不换行</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>为了让光标移到下一行的开头，可以在输出文本的结尾，添加一个换行符 \n 。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello World\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="④-标准库、头文件"><a href="#④-标准库、头文件" class="headerlink" title="④ 标准库、头文件"></a>④ 标准库、头文件</h4><p>printf() 是在标准库的头文件 <code>stdio.h</code> 中定义的。要想在程序中使用这个函数，必须在源文件头部引入这个头文件。即：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>何为标准库？</strong></p><p>程序需要用到的功能，不一定需要自己编写，C 语言可能已经自带了。程序员只要去调用这些自带的功能就可以了。C 语言自带的所有这些功能，统称为<code>“标准库”(standard library)</code>，包含C 内置函数、常量和头文件。</p><p>因为它们是写入标准的，到底包括哪些功能，应该怎么使用，都是规定好的，我们直接调用即可。</p><p><strong>何为头文件？</strong></p><p>不同的功能定义在不同的文件里，这些文件统称为<code>“头文件”(header file)</code>。如果系统自带某一个功能，就一定会自带描述这个功能的头文件，比如 printf() 的头文件就是系统自带的 <code>stdio.h</code> 。头文件的后缀通常是 <code>.h</code> 。</p><p><strong>预处理命令：#include命令</strong></p><p>如果要使用某个功能，就必须先加载其对应的头文件，加载使用的是 <code>#include</code> 命令，声明在各文件模块的开头。C语言中以 # 号开头的命令称为<code>预处理命令</code>。顾名思义，在编译器对当前C程序进行编译前执行预处理操作。</p><p>格式：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;头文件名&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>举例：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span>   </span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>注意，加载头文件的 #include 语句不需要分号结尾</p></blockquote><p>对比写法：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span><span class="token expression">： </span><span class="token comment">//编译系统在系统头文件所在目录搜索</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdio.h"</span><span class="token expression">： </span><span class="token comment">//编译系统首先在当前的源文件目录中查找 stdio.h，找不到的话，再转向系统头文件所在目录搜索。</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>stdio.h</code>是系统提供的一个文件名，<code>stdio</code>是standard input &amp; output的缩写。</p><p>结论：</p><ul><li>引用系统头文件，两种形式都会可以，<code>#include &lt;&gt; </code>效率高。</li></ul><ul><li>引用用户头文件，只能使用 <code>#include ""</code>。</li></ul><p><strong>常用的C头文件</strong></p><ul><li><code>stdio.h</code>——定义核心输入和输出函数<ul><li>printf()、scanf()、getchar()、putchar()</li></ul></li><li><code>stdlib.h</code>——定义数值转换函数、伪随机网络生成器和内存分配</li><li><code>string.h</code>——定义字符串处理函数</li><li><code>stdint.h</code>——定义精确宽度的整数类型</li><li><code>math.h</code>——定义常用的数学函数<ul><li>sin()、sqrt()</li></ul></li><li><code>stddef.h</code>——定义了几个有用的类型和宏</li></ul><p>练习：</p><blockquote><p>以下叙述中正确的是（　）。<br>A．C程序中的注释只能出现在程序的开始位置和语句的后面<br>B．C程序书写格式严格，要求一行内只能写一个语句<br>C．C程序书写格式自由，一个语句可以写在多行上<br>D．用C语言编写的程序只能放在一个程序文件中</p><p>【答案】C</p><p>【解析】C程序的注释可以出现在C程序的任何位置，注释符号：“//”或“/<em>…</em>/”，选项A错误。C程序中，一行内可写多个语句，每条语句用分号“；”结束，选项B错误，选项C正确。用C语言编写的程序可以放在多个程序文件中，用#include命令行实现文件包含功能，选项D错误。答案选择C选项。</p></blockquote><blockquote><p> 【中央财经大学2018研】以下叙述错误的是（　）。<br> A．在程序中凡是以“#”开始的语句行都是预处理命令行<br> B．预处理命令行的最后不能以分号表示结束<br> C．#include MAX是合法的宏定义命令行<br> D．C程序对预处理命令行的处理是在程序执行的过程中进行的</p><p> 【答案】D</p><p> 【解析】在C语言中，凡是以“#”开头的行都称为编译预处理命令行，为了区别C语句，后面是不加分号的。编译预处理是在编译程序对C源程序进行编译前执行的，而不是在程序执行过程中进行的。</p></blockquote><p><strong>注意：</strong></p><blockquote><p>学习编程最容易犯的错是<code>语法错误</code>。C语言要求必须按照语法规则编写代码。如果你的程序违反了语法规则，例如：忘记了分号、大括号、引号 或者拼错了单词等，C编译器都会报语法错误。<code>尝试着去看懂编译器会报告的错误信息</code>。</p></blockquote><h2 id="7、关于输出"><a href="#7、关于输出" class="headerlink" title="7、关于输出"></a>7、关于输出</h2><h3 id="7-1-printf-标准格式"><a href="#7-1-printf-标准格式" class="headerlink" title="7.1 printf()标准格式"></a>7.1 printf()标准格式</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span>格式控制字符串<span class="token punctuation">,</span>输出列表<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image-20230822164051224.png" alt="image-20230822164051224"></p><p>其中，</p><ul><li><p><code>"格式控制字符串"</code>是用双引号括起来的一个字符串。包括：</p><ul><li>普通字符：普通字符即需要在输出时原样输出的字符。</li><li>占位符：由“%”和格式字符组成。这个位置可以用其它值代入。</li></ul></li><li><p><code>"输出列表"</code>是程序需要输出的一些数据，可以是常量、变量或表达式。用于替换占位符的位置。</p></li></ul><blockquote><p>注意：printf() 参数与占位符是一一对应关系。如果参数个数少于对应的占位符， printf() 可能会输出内存中的任意值。</p></blockquote><h3 id="7-2-占位符"><a href="#7-2-占位符" class="headerlink" title="7.2 占位符"></a>7.2 占位符</h3><p>占位符的第一个字符是 <code>%</code> ，第二个字符表示占位符的类型。</p><p>printf() 的占位符有许多种类，与 C 语言的数据类型相对应。</p><p>下面按照字母顺序，列出占位符如下，方便查阅(红色为常用的)：</p><blockquote><p>%a ：浮点数(仅C99有效)<br>%A ：浮点数(仅C99有效)<br><strong>%c ：char型数据</strong><br><strong>%d ：十进制整数(int)</strong><br>%e ：使用科学计数法的浮点数，指数部分的 e 为小写<br>%E ：使用科学计数法的浮点数，指数部分的 E 为大写<br>%i ：整数，基本等同于 %d<br><strong>%f ：浮点数(float)</strong><br>%g ：6个有效数字的浮点数。整数部分一旦超过6位，就会自动转为科学计数法，指数部分的 e 为小写<br>%G ：等同于 %g ，唯一的区别是指数部分的 E 为大写<br>%hd ：十进制 short int 类型<br>%ho ：八进制 short int 类型<br>%hx ：十六进制 short int 类型<br>%hu ：unsigned short int 类型<br><strong>%ld ：十进制整数(long)</strong><br>%lo ：八进制 long int 类型<br>%lx ：十六进制 long int 类型<br>%lu ：unsigned long int 类型<br>%lld ：十进制 long long int 类型<br>%llo ：八进制 long long int 类型<br>%llx ：十六进制 long long int 类型<br>%llu ：unsigned long long int 类型<br>%le ：科学计数法表示的 long double 类型浮点数<br><strong>%lf ：十进制浮点数(double)</strong><br>%n ：已输出的字符串数量。该占位符本身不输出，只将值存储在指定变量之中<br>%o ：八进制整数<br><strong>%p ：指针</strong><br><strong>%s ：字符串</strong><br><strong>%u ：十进制无符号整数（unsigned int）</strong><br>%x ：十六进制整数<br>%zd ： size_t 类型<br>%% ：输出一个百分号</p></blockquote><h3 id="7-3-举例"><a href="#7-3-举例" class="headerlink" title="7.3 举例"></a>7.3 举例</h3><p><strong>举例1：%d</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"count is %d\n"</span><span class="token punctuation">,</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//输出：count is 10  </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"There are %i students\n"</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//输出：There are 5 students</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>举例2：%lf 和 %f</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">float</span> f <span class="token operator">=</span> <span class="token number">3.1415926535f</span><span class="token punctuation">;</span>    <span class="token comment">// 单精度浮点数</span><span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token number">3.1415926535</span><span class="token punctuation">;</span>  <span class="token comment">// 双精度浮点数</span><span class="token comment">// 使用 %f 输出单精度浮点数</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Float: %f\n"</span><span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//Float: 3.141593</span><span class="token comment">// 使用 %lf 输出双精度浮点数</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Double: %lf\n"</span><span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//Double: 3.141593</span><span class="token comment">// 使用 %f 输出单精度浮点数</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Float: %.8f\n"</span><span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//Float: 3.14159274</span><span class="token comment">// 使用 %lf 输出双精度浮点数</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Double: %.8lf\n"</span><span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//Double: 3.14159265</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>举例3：%c</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> level <span class="token operator">=</span> <span class="token char">'A'</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"this score level is:%c\n"</span><span class="token punctuation">,</span>level<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//输出：this score level is:A</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>举例4：%s</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s是我最喜欢的冷门歌手.\n"</span><span class="token punctuation">,</span><span class="token string">"孙燕姿"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//输出：孙燕姿是我最喜欢的冷门歌手.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>举例5：多个占位符</strong></p><p>输出文本里面可以使用多个占位符。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s有%d部手机\n"</span><span class="token punctuation">,</span> <span class="token string">"老板"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//输出：老板有2部手机</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="7-4-输出格式"><a href="#7-4-输出格式" class="headerlink" title="7.4 输出格式"></a>7.4 输出格式</h3><p>printf() 可以定制占位符的输出格式。</p><p><strong>格式1：限定宽度</strong></p><p>printf() 允许限定占位符的最小宽度。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%5d\n"</span><span class="token punctuation">,</span> <span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出为 "  123" </span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>说明：%5d 表示这个占位符的宽度至少为5位。如果不满5位，对应的值的前面会添加空格。</p><p>输出的值默认是右对齐，即输出内容前面会有空格；如果希望改成左对齐，在输出内容后面添加空格，可以在占位符的 % 的后面插入一个 - 号。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%-5d\n"</span><span class="token punctuation">,</span> <span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出为 "123  "</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对于小数，这个限定符会限制所有数字的最小显示宽度</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%12f\n"</span><span class="token punctuation">,</span> <span class="token number">123.45</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 "  123.450000"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>%12f 表示输出的浮点数最少要占据12位。由于小数的默认显示精度是小数点后6位，所以123.45 输出结果的头部会添加2个空格。</p><p><strong>格式2：总是显示正负号</strong></p><p>默认情况下， printf() 不对正数显示 + 号，只对负数显示 - 号。如果想让正数也输出 + 号，可以在占位符的 % 后面加一个 + 。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%+d\n"</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 +11</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%+d\n"</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 -11</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>格式3：限定小数位数</strong></p><p>输出小数时，有时希望限定小数的位数。举例来说，希望小数点后面只保留两位，占位符可以写成 %.2f 。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Number is %.2f\n"</span><span class="token punctuation">,</span> <span class="token number">0.8</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 Number is 0.80</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这种写法可以与限定宽度占位符，结合使用。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%6.2f\n"</span><span class="token punctuation">,</span> <span class="token number">0.8</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出为 "  0.80"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>说明：%6.2f 表示输出字符串最小宽度为6，小数位数为2。整体长度不足 6 位时，右对齐显示。</p><p>最小宽度和小数位数这两个限定值，都可以用 * 代替，通过 printf() 的参数传入。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%*.*f\n"</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0.8</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//等同于</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%6.2f\n"</span><span class="token punctuation">,</span> <span class="token number">0.8</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p> 【华南理工大学2018研】十六进制形式输出整数的格式说明符是（　）。</p><p> A．%u<br> B．%ld<br> C．%x<br> D．%o</p><p> 【答案】C</p><p> 【解析】A表示输出的是无符号整型；B表示输出的是有符号长整型；D表示输出的是八进制。</p></blockquote><h2 id="8、练习"><a href="#8、练习" class="headerlink" title="8、练习"></a>8、练习</h2><p>练习1：开发一个 ILoveC.c 程序，可以输出 “某某 is studying c!”</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//printf("谷小妹 is studying C!\n");</span>    <span class="token comment">//printf("%s is studying C!\n","谷小妹");</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>练习2：控制台打印：5 + 3 = 8</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d + %d = %d\n"</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">5</span> <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//函数结束</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="附录：C-x2F-C-Single-File-Execution插件的安装"><a href="#附录：C-x2F-C-Single-File-Execution插件的安装" class="headerlink" title="附录：C/C++ Single File Execution插件的安装"></a>附录：C/C++ Single File Execution插件的安装</h2><p><strong>1、为何安装C/C++ Single File Execution插件？</strong></p><p>前面已经创建了一个demo1工程，项目文件夹内存在一个代码文件，名为<code>main.c</code>。如果再创建一个C源文件，内部如果也包含main()函数，则会报错！因为默认C工程下只能有一个main()函数。如何解决此问题呢？</p><p>2、安装并测试</p><p>1）在 File - Settings - Plugins 中搜索 <code>C/C++ Single File Execution</code> 插件并安装</p><p><img src="/images/image-20230823145107293.png" alt="image-20230823145107293"></p><p>2）在需要运行的代码中右键，点击 Add executable for single c/cpp file</p><p><img src="/images/1692774502830.png" alt="1692774502830"></p><p>3）此时可以在 Cmakelists.text 文件中看到多出的这一行代码，这就是插件帮我们完成的事情</p><p><img src="/images/1692774556495.png" alt="1692774556495"></p><p>4）右键项目文件夹，点击 Reload CMake Project 进行刷新</p><p><img src="/images/1692774575597.png" alt="1692774575597"></p><p>5）此时右上角标签处已经增加了我们的文件选项，选择需要的标签</p><p><img src="/images/1692774598633.png" alt="1692774598633"></p><p>6）点击小三角，或右键代码处点击 Run 选项，即可运行代码。</p><p><img src="/images/1692774678384.png" alt="1692774678384"></p><p>7）在该工程下创建main2.c文件，文件中的代码如下所示，执行上面相同的步骤。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello, World2!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以发现一个工程中允许存在多个main方法了，而且可以独立允许。</p>]]></content>
      
      
      <categories>
          
          <category> 技术区 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react_fiber</title>
      <link href="/2024/04/14/02-react-yuan-ma/react-fiber/"/>
      <url>/2024/04/14/02-react-yuan-ma/react-fiber/</url>
      
        <content type="html"><![CDATA[<h1 id="fiber之前"><a href="#fiber之前" class="headerlink" title="fiber之前"></a>fiber之前</h1>]]></content>
      
      
      <categories>
          
          <category> 技术区 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>给定一个不重复的正整数集合A，从中取N个数字，使他们的和为M的所有可能</title>
      <link href="/2024/03/21/01-suan-fa/0001/"/>
      <url>/2024/03/21/01-suan-fa/0001/</url>
      
        <content type="html"><![CDATA[<h1 id="给定一个不重复的正整数集合A，从中取N个数字，使他们的和为M的所有可能。"><a href="#给定一个不重复的正整数集合A，从中取N个数字，使他们的和为M的所有可能。" class="headerlink" title="给定一个不重复的正整数集合A，从中取N个数字，使他们的和为M的所有可能。"></a>给定一个不重复的正整数集合A，从中取N个数字，使他们的和为M的所有可能。</h1><h2 id="一、故事的背景"><a href="#一、故事的背景" class="headerlink" title="一、故事的背景"></a>一、故事的背景</h2><blockquote><p>这道题曾是笔者在21年碰到的高频面试题，一些大厂非常喜欢考这道题，当时自己没有复盘在面试过程中中来来回回碰到了3次都被解决，故而痛定思痛，最终把这到题深深刻在自己的 <code>DNA</code>上，以思其过。</p></blockquote><h2 id="二、算法的前置知识"><a href="#二、算法的前置知识" class="headerlink" title="二、算法的前置知识"></a>二、算法的前置知识</h2><ul><li>二进制、位运算</li><li>剪枝的思想</li><li>时间、空间复杂度分析与优化</li></ul><h2 id="三、深入分析"><a href="#三、深入分析" class="headerlink" title="三、深入分析"></a>三、深入分析</h2><h3 id="3-1-降维分析、化繁为简"><a href="#3-1-降维分析、化繁为简" class="headerlink" title="3.1 降维分析、化繁为简"></a>3.1 降维分析、化繁为简</h3><p>首先我们从题干出发，题干信息很简单，核心问题在于</p><blockquote><p>如何从数组中选取 <code>N</code> 个数进行求和运算。</p></blockquote><p>假如 <code>N = 2</code> ，也就是找出数组中两个数的和为 <code>M</code> 的话，你可能会立马想到 <a href="https://leetcode.cn/problems/two-sum/description/">力扣</a> 中的第1题：两数和 的问题，即采用嵌套<code>for</code>循环的方式来解（时间复杂度<code>O(n^2)</code>，空间复杂度<code>O(1)</code>）。</p><p>但问题是 <code>N = 2</code> 或者 <code>N = 10+</code> 的话，会发现运算量越来越大，显然上面的方式已经行不通了。</p><p>我们不妨换个思想↓</p><p><strong>数组中选取不固定数值 <code>N</code> ，我们可以尝试着使用标记的方式，我们把 <code>1</code> 表示成选取状态， 把 <code>0</code> 表示成未选取状态。</strong></p><blockquote><p>假设我们有一个数组<code>arr = [1, 2, 3, 4]</code>，每一个元素都用 <code>0</code> 或  <code>1</code> 来标记，如果 <code>N=4</code> ，也就是在这个数组中，需要选择 <code>4</code> 个元素，那么对应的标记就只有一种可能 <code>1111</code> ，如果 <code>N=3</code> ，那就有 <code>4</code> 种可能，分别是 <code>1110</code> 、 <code>1101</code> 、<code>1011</code> 以及 <code>0111</code> 这 <code>4</code> 种可能。</p></blockquote><p>也就是说：</p><p><strong>标记中有几个 <code>1</code> 就是代表选取了几个数，然后再去遍历这些 <code>1</code> 所有可能存在的排列方式，最后做一个判断，这个判断就是：每一种排列方式，都代表着数组中不同位置的被选中的数的组合，所以这里就是将选中的这些数字，进行求和运算，然后判断求出的和是不是等于 <code>M</code> 。</strong></p><p>于是问题就变得简单了。</p><hr><h3 id="3-2-设计与数组的关联性"><a href="#3-2-设计与数组的关联性" class="headerlink" title="3.2 设计与数组的关联性"></a>3.2 设计与数组的关联性</h3><p>以上面的 <code>arr = [1, 2, 3, 4]</code> 为例，有 <code>4</code> 个元素，则我们选择元素的方式有从 <code>0000</code>（ <code>N = 0</code> ）到 <code>1111</code>( <code>N = 4</code> ) 的所有可能。而 <code>1111</code> 在二进制中对应的数字是<code>15</code>,也就是说在<code>N</code>不确定的情况,下我们选择的组合总共有<code>16</code>种。</p><p>这里我们采用位运算——&gt; <font color="#08e">左移</font> 运算。即<code>1 &lt;&lt; 4</code> 的结果为<code>16</code>。</p><blockquote><p>补充：如果<code>a</code>的二进制位<code>0111</code>, <code>a&lt;&lt;2</code>的结果为<code>11100</code>。</p></blockquote><p>对此，我们可以编码如下</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">// 用res盛放题目所有可能</span>    len <span class="token operator">=</span> <span class="token constant">A</span><span class="token punctuation">.</span>length<span class="token punctuation">,</span>    bit <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> len <span class="token comment">// 所有可能的数量</span><span class="token comment">// 这里忽略了 0 的情况(N = 0)，取值就是 1 - 15</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> bit<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// ...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>这里解释下为何我们要用<code>位运算</code>：由于我们考虑的是最优解，而位运算直接用二进制进行表示，计算机省去了中间过程的各种复杂转换，从而提高了速度。</p></blockquote><h3 id="3-3-设计二进制数中1的个数的功能函数"><a href="#3-3-设计二进制数中1的个数的功能函数" class="headerlink" title="3.3 设计二进制数中1的个数的功能函数"></a>3.3 设计二进制数中<code>1</code>的个数的功能函数</h3><p>首先补充下<code>位运算</code>的规则↓</p><blockquote><p>&amp; 按位与(遇0则0)<br>例子：var a=7,b=11;  a &amp; b的结果是？<br>a的二进制是0111，b的二进制是1011<br>规则：0对1、1对0、0对0==&gt;结果为0<br>1对1 ==&gt;结果为1<br>结果：<br> 0 1 1 1</p><p>1 0 1 1</p><p>0 0 1 1  ==&gt; 等于3<br>| 按位或(遇1则1)<br>规则：0对1、1对0、1对1==&gt;结果为1<br>0对0 ==&gt;结果为0</p></blockquote><p><strong>我们可以建立一个迭代，通过统计消除的次数，就能确定最终有几个 <code>1</code> 了。</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">/** * 用于计算二进制中1的数量 * @param {number} num 当前二进制对应的数字  * @returns  */</span><span class="token keyword">const</span> <span class="token function-variable function">n</span> <span class="token operator">=</span> <span class="token parameter">num</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token punctuation">{</span>        num <span class="token operator">&amp;=</span> num <span class="token operator">-</span> <span class="token number">1</span>        count<span class="token operator">++</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> count<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-设计计算和为M"><a href="#3-3-设计计算和为M" class="headerlink" title="3.3 设计计算和为M"></a>3.3 设计计算和为<code>M</code></h3><p>上一节中我们已经筛选出所有取<code>N</code>个数字的所有排列，这时我们还需要再次筛选，即：我们需要从第一次筛选的排列中找到和为<code>M</code>的所有组合，而这些组合就是我们的答案。</p><p>那么问题来了，我们如何去找出这些数呢？答案还是通过<code>左移</code>。</p><blockquote><p>比如：<code>14</code> 的二进制表示为 <code>1110</code>，其代表（从右往左）选取了第 <code>2</code> , <code>3</code> , <code>4</code> 位。</p><p>1110 &amp; 0001（1&lt;&lt;0） === 0000   等与0，第一位不选取</p><p>1110 &amp; 0010 （1&lt;&lt;1）=== 0010  不等于0，第二位选取</p><p>1110 &amp; 0100 （1&lt;&lt; 2) === 0100  不等于0，第三位选取</p><p>1110 &amp; 1000 （1&lt;&lt;3）=== 1000  不等于0，第四位选取</p></blockquote><p>所以我们可以推出第二次筛选的代码</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 所以， 1110 对应着 第一位没有选取，那么 1110 &amp; 0001(设置为第一位的位掩码) = 0，如果 i &amp; (1 &lt;&lt; inx) !== 0 代表该位被选取了</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> j<span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 代表这个数被选取了，我们做累加求和就行</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-得出结果"><a href="#3-4-得出结果" class="headerlink" title="3.4 得出结果"></a>3.4 得出结果</h3><p>最终，我们的代码如下</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token parameter"><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">N</span><span class="token punctuation">,</span> <span class="token constant">M</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">/**   * 用于计算二进制中1的数量   * @param {number} num 当前二进制对应的数字    * @returns    */</span>  <span class="token keyword">const</span> <span class="token function-variable function">n</span> <span class="token operator">=</span> <span class="token parameter">num</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token punctuation">{</span>      num <span class="token operator">&amp;=</span> num <span class="token operator">-</span> <span class="token number">1</span>      count<span class="token operator">++</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> count  <span class="token punctuation">}</span>  <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    len <span class="token operator">=</span> <span class="token constant">A</span><span class="token punctuation">.</span>length<span class="token punctuation">,</span>    bit <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> len  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> bit<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">n</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token constant">N</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>        temp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          s <span class="token operator">+=</span> <span class="token constant">A</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>          temp<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">===</span> <span class="token constant">M</span><span class="token punctuation">)</span> res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> res<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-5-复杂度分析"><a href="#3-5-复杂度分析" class="headerlink" title="3.5 复杂度分析"></a>3.5 复杂度分析</h3><ul><li><p><font color="#f90">时间复杂度：</font></p><ul><li><code>n(num)</code> 函数用于计算一个数字在二进制表示中1的个数。它使用了<code>num &amp;= num - 1</code>这个技巧来消除最低位的1，直到<code>num</code>变为0。每次循环，<code>num</code>至少减少一个1，因此最多循环<code>num</code>中1的个数次。在最坏情况下，<code>num</code>是一个全1的二进制数，即<code>2^len - 1</code>，其中<code>len</code>是集合A的长度。因此，<code>n(num)</code>的时间复杂度是O(n)。</li><li>外层循环<code>for (let i = 1; i &lt; bit; i++)</code>遍历了所有可能的子集，其中<code>bit = 1 &lt;&lt; len</code>，即<code>2^len</code>。因此，外层循环的次数是<code>2^n</code>。</li><li>内层循环<code>for (let j = 0; j &lt; len; j++)</code>对于每个<code>i</code>，都遍历了集合A的所有元素，所以它的时间复杂度是O(n)。</li></ul><p>综上所述，总的时间复杂度是外层循环的次数乘以内层循环的次数再乘以<code>n(num)</code>的时间复杂度，即O(len * 2^len * len) = O(n^2 * 2^n)。</p></li><li><p><font color="#f90">空间复杂度：</font></p><ul><li><code>res</code>数组用于存储所有满足条件的子集，其最大长度取决于满足条件的子集数量。在最坏情况下，所有<code>2^len</code>个子集中可能有多个满足条件，因此<code>res</code>的空间复杂度可能是O(2^len)，但这取决于实际满足条件的子集数量。</li><li><code>temp</code>数组用于存储当前正在检查的子集，其长度最多为<code>len</code>，因此它的空间复杂度是O(n)。</li><li><code>n(num)</code>函数中的<code>count</code>变量和循环中的其他局部变量占用的空间是常量级的，可以忽略不计。</li></ul><p>因此，空间复杂度主要由<code>res</code>数组决定，如果考虑最坏情况，则是O(2^n)。如果考虑平均情况或实际情况（满足条件的子集数量较少），则空间复杂度可能会低于O(2^n)。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法区 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础知识</title>
      <link href="/2023/06/05/03-python-xue-xi/python-zong-bi-ji/"/>
      <url>/2023/06/05/03-python-xue-xi/python-zong-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="一、前置知识"><a href="#一、前置知识" class="headerlink" title="一、前置知识"></a>一、前置知识</h1><h2 id="1-1-Python的起源"><a href="#1-1-Python的起源" class="headerlink" title="1.1 Python的起源"></a>1.1 Python的起源</h2><ul><li>1989年，为了打发圣诞节假期，Gudio van Rossum 吉多·范罗苏姆（龟叔）觉醒开发一个新的解释程序。</li><li>1991你那，第一个Python解释器诞生。</li><li>Python这个名字，来自龟叔所致爱的电视剧<code>Monty Python's Flying Circus</code></li></ul><h2 id="1-2-为什么选择python"><a href="#1-2-为什么选择python" class="headerlink" title="1.2 为什么选择python"></a>1.2 为什么选择python</h2><table><thead><tr><th>人群</th><th>用Python做什么</th></tr></thead><tbody><tr><td>IT从业者</td><td>自动化脚本（运维开发、测试开发等）</td></tr><tr><td>普通白领</td><td>自动化办公</td></tr><tr><td>后端开发</td><td>Web引用程序</td></tr><tr><td>科学家</td><td>基于Python完成数据计算（生物、化学、物理）</td></tr><tr><td><strong>人工智能/机器学习</strong></td><td><strong>基于Python开发AI程序</strong></td></tr><tr><td><strong>大数据开发</strong></td><td><strong>基于Python完成大数据任务开发（Spark、Flink）</strong></td></tr></tbody></table><h2 id="1-2安装Python"><a href="#1-2安装Python" class="headerlink" title="1.2安装Python"></a>1.2安装Python</h2><p><a href="https://www.python.org/">python官网</a></p><p>注意事项：<font color="red">安装的时候移动要勾选下图所示的框</font></p><p><img src="/../../images/03/01%E3%80%81%E5%AE%89%E8%A3%85.png"> </p>]]></content>
      
      
      <categories>
          
          <category> 技术区 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react18源码解读</title>
      <link href="/2023/06/05/02-react-yuan-ma/react-react18/"/>
      <url>/2023/06/05/02-react-yuan-ma/react-react18/</url>
      
        <content type="html"><![CDATA[<h2 id="一、写在开头"><a href="#一、写在开头" class="headerlink" title="一、写在开头"></a>一、写在开头</h2><p>首先让我们从源头开始出发</p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx"><span class="token keyword">import</span> <span class="token punctuation">{</span> createRoot <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react-dom/client'</span><span class="token punctuation">;</span><span class="token keyword">const</span> element <span class="token operator">=</span> <span class="token punctuation">(</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">        hello&lt;span style=</span><span class="token punctuation">{</span><span class="token punctuation">{</span> color<span class="token operator">:</span> <span class="token string">'red'</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token plain-text">&gt;world</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> root <span class="token operator">=</span> <span class="token function">createRoot</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'root'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>root<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>react整体渲染过程主要用到了两个方法，即 <code>createRoot</code> 和 <code>render</code> 方法，createRoot方法主要是创建根 Fiber 与其真实DOM根节点之间的联系；而<code>render</code> 方法负责Fiber树的生成以及将Fiber树变成真实DOM树并渲染的一个过程。</p><h2 id="二、createRoot方法主要做了什么？"><a href="#二、createRoot方法主要做了什么？" class="headerlink" title="二、createRoot方法主要做了什么？"></a>二、createRoot方法主要做了什么？</h2><h3 id="2-1-大致流程"><a href="#2-1-大致流程" class="headerlink" title="2.1  大致流程"></a>2.1  大致流程</h3><ol><li>通过<code>createContainer</code> 方法创建<strong>FiberNode</strong>的一个根实例，即<font color="#f00">未初始化的根Fiber</font>。</li><li>建立 <code>FiberRootNode</code>与 <code>HostRootFiber</code>之间的联系。</li><li>初始化循环队列。</li><li>返回 <code>FiberRootNode</code>。</li></ol><blockquote><p>附上完整的实现方法</p></blockquote><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">createRoot</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 这里的root即构造函数FiberRootNode的一个实例,相当于根Fiber</span>    <span class="token comment">// FiberRootNode里面有一个containerInfo属性，this.containerInfo ==&gt; div#root</span>    <span class="token keyword">const</span> root <span class="token operator">=</span> <span class="token function">createContainer</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Fiber挂载到ReactDOMRoot的实例的一个属性_internalRoot上</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ReactDOMRoot</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">createContainer</span><span class="token punctuation">(</span>containerInfo<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">createFiberRoot</span><span class="token punctuation">(</span>containerInfo<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color="#f00">注意：下面的代码是<strong>createRoot</strong>核心做的事情</font></p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">createFiberRoot</span><span class="token punctuation">(</span>containerInfo<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// containerInfo ==&gt; div#root</span>    <span class="token keyword">const</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FiberRootNode</span><span class="token punctuation">(</span>containerInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// HostRoot指的就是根节点div#root,HostRootFiber代表根Fiber</span>    <span class="token keyword">const</span> uninitializedFiber <span class="token operator">=</span> <span class="token function">createHostRootFiber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 根容器的current指向当前的根容器(根fiber)现在正在显示或者已经渲染好的fiber树</span>    root<span class="token punctuation">.</span>current <span class="token operator">=</span> uninitializedFiber<span class="token punctuation">;</span>    <span class="token comment">// 根fiber的stateNode,也就是真实dom节点指向FiberRootNode</span>    uninitializedFiber<span class="token punctuation">.</span>stateNode <span class="token operator">=</span> root<span class="token punctuation">;</span>    <span class="token comment">// 开始初始化更新队列</span>    <span class="token function">initialUpdateQueue</span><span class="token punctuation">(</span>uninitializedFiber<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> root<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color="#08e">根Fiber大致长这个样↓</font></p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx"><span class="token comment">/** * * @param {*} tag fiber的类型 函数组件0 类组件1 原生组件5 根元素3 * @param {*} pendingProps 新属性，等待处理或者说生效的属性 * @param {*} key 唯一标识 */</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">FiberNode</span><span class="token punctuation">(</span>tag<span class="token punctuation">,</span> pendingProps<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>tag <span class="token operator">=</span> tag<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// fiber类型，来自于虚拟DOM节点的type, span div p</span>    <span class="token comment">// 每个虚拟DOM =&gt; Fiber节点 =&gt; 真实DOM</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>stateNode <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 此fiber对应的真实dom节点 h1 =&gt; 真实的h1 DOM</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>return <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 指向父节点</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>child <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 指向第一个子节点</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>sibling <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 指向next弟弟节点</span>    <span class="token comment">// fiber哪来的？通过虚拟DOM节点创建，虚拟DOM会提供pendingProps用来创建fiber节点的属性</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>pendingProps <span class="token operator">=</span> pendingProps<span class="token punctuation">;</span> <span class="token comment">// 等待生效的属性</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>memoizedProps <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 已经生效的属性</span>    <span class="token comment">// 每个fiber还会有自己的状态，每一种fiber状态的类型是不一样的</span>    <span class="token comment">// 类组件对应的fiber存的就是类的实例的状态，HostRoot存的就是要渲染的元素</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>memoizedState <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token comment">// 每个fiber身上可能还有更新队列</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>undateQueue <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token comment">// 自身副作用的标识，表示要针对此fiber节点的进行何种操作</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>flags <span class="token operator">=</span> NoFlags<span class="token punctuation">;</span> <span class="token comment">// 自己的副作用</span>    <span class="token comment">// 子节点对应的副作用使用标识，主要是为了提升性能(eg:如果副作用标识是0，那么后面的子节点就不用递归计算了)</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>subtreeFlags <span class="token operator">=</span> NoFlags<span class="token punctuation">;</span>    <span class="token comment">// 替身(相当于使用了双缓存技术或者说是预加载技术)</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>alternate <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token comment">// 默认索引值</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">createFiber</span><span class="token punctuation">(</span>tag<span class="token punctuation">,</span> pendingProps<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FiberNode</span><span class="token punctuation">(</span>tag<span class="token punctuation">,</span> pendingProps<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">createHostRootFiber</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">createFiber</span><span class="token punctuation">(</span>HostRoot<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以下是初始化循环队列的方法</p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">initialUpdateQueue</span><span class="token punctuation">(</span>fiber<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 创建一个新的更新队列</span>    <span class="token comment">// pending其实是一个循环链表</span>    <span class="token keyword">const</span> queue <span class="token operator">=</span> <span class="token punctuation">{</span>        shared<span class="token operator">:</span> <span class="token punctuation">{</span>            pending<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    fiber<span class="token punctuation">.</span>updateQueue <span class="token operator">=</span> queue<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-图文解析"><a href="#2-2-图文解析" class="headerlink" title="2.2 图文解析"></a>2.2 图文解析</h3><p><img src="/../images/02/01%E3%80%81createFiber.jpg" alt="createfiber结构图"></p><p><img src="/../images/02/02%E3%80%81createRoot%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="createfiber细节图"></p>]]></content>
      
      
      <categories>
          
          <category> 技术区 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>序章</title>
      <link href="/2023/05/20/00-xu-zhang/hello-world/"/>
      <url>/2023/05/20/00-xu-zhang/hello-world/</url>
      
        <content type="html"><![CDATA[<h1 id="序章"><a href="#序章" class="headerlink" title="序章"></a>序章</h1><p>不知不觉从19年毕业直到现在，从事着web前端开发这块也有好几年的时间了。</p><p>在此期间大大小小的笔记也做了蛮多，</p><p>从最初用的有道笔记、到现在用到的csdn、语雀、知乎、github，</p><p>才发现自己写的东西已经不知道去哪个平台回顾了（主要是懒 ^ ^）</p><p>为此思来思去，经过这几天的折腾，终于把自己的个人网站搭建起来了；</p><p>接下来的这几个月，我会针对于自己所学的知识把大前端各个分支进行分类与整合并发布到这个网站上来。</p><p>学习与写博客是一件持之以恒的事情，</p><p>这也是不断督促自己前进的一种方式；</p><p>就让我们开始行动起来吧~</p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">document<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'here we go'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 生活区 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
