<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>react_fiber</title>
      <link href="/2024/04/14/02-react-yuan-ma/react-fiber/"/>
      <url>/2024/04/14/02-react-yuan-ma/react-fiber/</url>
      
        <content type="html"><![CDATA[<h1 id="fiber之前"><a href="#fiber之前" class="headerlink" title="fiber之前"></a>fiber之前</h1>]]></content>
      
      
      <categories>
          
          <category> 技术区 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>给定一个不重复的正整数集合A，从中取N个数字，使他们的和为M的所有可能</title>
      <link href="/2024/03/21/01-suan-fa/0001/"/>
      <url>/2024/03/21/01-suan-fa/0001/</url>
      
        <content type="html"><![CDATA[<h1 id="给定一个不重复的正整数集合A，从中取N个数字，使他们的和为M的所有可能。"><a href="#给定一个不重复的正整数集合A，从中取N个数字，使他们的和为M的所有可能。" class="headerlink" title="给定一个不重复的正整数集合A，从中取N个数字，使他们的和为M的所有可能。"></a>给定一个不重复的正整数集合A，从中取N个数字，使他们的和为M的所有可能。</h1><h2 id="一、故事的背景"><a href="#一、故事的背景" class="headerlink" title="一、故事的背景"></a>一、故事的背景</h2><blockquote><p>这道题曾是笔者在21年碰到的高频面试题，一些大厂非常喜欢考这道题，当时自己没有复盘在面试过程中中来来回回碰到了3次都被解决，故而痛定思痛，最终把这到题深深刻在自己的 <code>DNA</code>上，以思其过。</p></blockquote><h2 id="二、算法的前置知识"><a href="#二、算法的前置知识" class="headerlink" title="二、算法的前置知识"></a>二、算法的前置知识</h2><ul><li>二进制、位运算</li><li>剪枝的思想</li><li>时间、空间复杂度分析与优化</li></ul><h2 id="三、深入分析"><a href="#三、深入分析" class="headerlink" title="三、深入分析"></a>三、深入分析</h2><h3 id="3-1-降维分析、化繁为简"><a href="#3-1-降维分析、化繁为简" class="headerlink" title="3.1 降维分析、化繁为简"></a>3.1 降维分析、化繁为简</h3><p>首先我们从题干出发，题干信息很简单，核心问题在于</p><blockquote><p>如何从数组中选取 <code>N</code> 个数进行求和运算。</p></blockquote><p>假如 <code>N = 2</code> ，也就是找出数组中两个数的和为 <code>M</code> 的话，你可能会立马想到 <a href="https://leetcode.cn/problems/two-sum/description/">力扣</a> 中的第1题：两数和 的问题，即采用嵌套<code>for</code>循环的方式来解（时间复杂度<code>O(n^2)</code>，空间复杂度<code>O(1)</code>）。</p><p>但问题是 <code>N = 2</code> 或者 <code>N = 10+</code> 的话，会发现运算量越来越大，显然上面的方式已经行不通了。</p><p>我们不妨换个思想↓</p><p><strong>数组中选取不固定数值 <code>N</code> ，我们可以尝试着使用标记的方式，我们把 <code>1</code> 表示成选取状态， 把 <code>0</code> 表示成未选取状态。</strong></p><blockquote><p>假设我们有一个数组<code>arr = [1, 2, 3, 4]</code>，每一个元素都用 <code>0</code> 或  <code>1</code> 来标记，如果 <code>N=4</code> ，也就是在这个数组中，需要选择 <code>4</code> 个元素，那么对应的标记就只有一种可能 <code>1111</code> ，如果 <code>N=3</code> ，那就有 <code>4</code> 种可能，分别是 <code>1110</code> 、 <code>1101</code> 、<code>1011</code> 以及 <code>0111</code> 这 <code>4</code> 种可能。</p></blockquote><p>也就是说：</p><p><strong>标记中有几个 <code>1</code> 就是代表选取了几个数，然后再去遍历这些 <code>1</code> 所有可能存在的排列方式，最后做一个判断，这个判断就是：每一种排列方式，都代表着数组中不同位置的被选中的数的组合，所以这里就是将选中的这些数字，进行求和运算，然后判断求出的和是不是等于 <code>M</code> 。</strong></p><p>于是问题就变得简单了。</p><hr><h3 id="3-2-设计与数组的关联性"><a href="#3-2-设计与数组的关联性" class="headerlink" title="3.2 设计与数组的关联性"></a>3.2 设计与数组的关联性</h3><p>以上面的 <code>arr = [1, 2, 3, 4]</code> 为例，有 <code>4</code> 个元素，则我们选择元素的方式有从 <code>0000</code>（ <code>N = 0</code> ）到 <code>1111</code>( <code>N = 4</code> ) 的所有可能。而 <code>1111</code> 在二进制中对应的数字是<code>15</code>,也就是说在<code>N</code>不确定的情况,下我们选择的组合总共有<code>16</code>种。</p><p>这里我们采用位运算——&gt; <font color="#08e">左移</font> 运算。即<code>1 &lt;&lt; 4</code> 的结果为<code>16</code>。</p><blockquote><p>补充：如果<code>a</code>的二进制位<code>0111</code>, <code>a&lt;&lt;2</code>的结果为<code>11100</code>。</p></blockquote><p>对此，我们可以编码如下</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">// 用res盛放题目所有可能</span>    len <span class="token operator">=</span> <span class="token constant">A</span><span class="token punctuation">.</span>length<span class="token punctuation">,</span>    bit <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> len <span class="token comment">// 所有可能的数量</span><span class="token comment">// 这里忽略了 0 的情况(N = 0)，取值就是 1 - 15</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> bit<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// ...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>这里解释下为何我们要用<code>位运算</code>：由于我们考虑的是最优解，而位运算直接用二进制进行表示，计算机省去了中间过程的各种复杂转换，从而提高了速度。</p></blockquote><h3 id="3-3-设计二进制数中1的个数的功能函数"><a href="#3-3-设计二进制数中1的个数的功能函数" class="headerlink" title="3.3 设计二进制数中1的个数的功能函数"></a>3.3 设计二进制数中<code>1</code>的个数的功能函数</h3><p>首先补充下<code>位运算</code>的规则↓</p><blockquote><p>&amp; 按位与(遇0则0)<br>例子：var a=7,b=11;  a &amp; b的结果是？<br>a的二进制是0111，b的二进制是1011<br>规则：0对1、1对0、0对0==&gt;结果为0<br>1对1 ==&gt;结果为1<br>结果：<br> 0 1 1 1</p><p>1 0 1 1</p><p>0 0 1 1  ==&gt; 等于3<br>| 按位或(遇1则1)<br>规则：0对1、1对0、1对1==&gt;结果为1<br>0对0 ==&gt;结果为0</p></blockquote><p><strong>我们可以建立一个迭代，通过统计消除的次数，就能确定最终有几个 <code>1</code> 了。</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">/** * 用于计算二进制中1的数量 * @param {number} num 当前二进制对应的数字  * @returns  */</span><span class="token keyword">const</span> <span class="token function-variable function">n</span> <span class="token operator">=</span> <span class="token parameter">num</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token punctuation">{</span>        num <span class="token operator">&amp;=</span> num <span class="token operator">-</span> <span class="token number">1</span>        count<span class="token operator">++</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> count<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-设计计算和为M"><a href="#3-3-设计计算和为M" class="headerlink" title="3.3 设计计算和为M"></a>3.3 设计计算和为<code>M</code></h3><p>上一节中我们已经筛选出所有取<code>N</code>个数字的所有排列，这时我们还需要再次筛选，即：我们需要从第一次筛选的排列中找到和为<code>M</code>的所有组合，而这些组合就是我们的答案。</p><p>那么问题来了，我们如何去找出这些数呢？答案还是通过<code>左移</code>。</p><blockquote><p>比如：<code>14</code> 的二进制表示为 <code>1110</code>，其代表（从右往左）选取了第 <code>2</code> , <code>3</code> , <code>4</code> 位。</p><p>1110 &amp; 0001（1&lt;&lt;0） === 0000   等与0，第一位不选取</p><p>1110 &amp; 0010 （1&lt;&lt;1）=== 0010  不等于0，第二位选取</p><p>1110 &amp; 0100 （1&lt;&lt; 2) === 0100  不等于0，第三位选取</p><p>1110 &amp; 1000 （1&lt;&lt;3）=== 1000  不等于0，第四位选取</p></blockquote><p>所以我们可以推出第二次筛选的代码</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 所以， 1110 对应着 第一位没有选取，那么 1110 &amp; 0001(设置为第一位的位掩码) = 0，如果 i &amp; (1 &lt;&lt; inx) !== 0 代表该位被选取了</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> j<span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 代表这个数被选取了，我们做累加求和就行</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-得出结果"><a href="#3-4-得出结果" class="headerlink" title="3.4 得出结果"></a>3.4 得出结果</h3><p>最终，我们的代码如下</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token parameter"><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">N</span><span class="token punctuation">,</span> <span class="token constant">M</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">/**   * 用于计算二进制中1的数量   * @param {number} num 当前二进制对应的数字    * @returns    */</span>  <span class="token keyword">const</span> <span class="token function-variable function">n</span> <span class="token operator">=</span> <span class="token parameter">num</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token punctuation">{</span>      num <span class="token operator">&amp;=</span> num <span class="token operator">-</span> <span class="token number">1</span>      count<span class="token operator">++</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> count  <span class="token punctuation">}</span>  <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    len <span class="token operator">=</span> <span class="token constant">A</span><span class="token punctuation">.</span>length<span class="token punctuation">,</span>    bit <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> len  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> bit<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">n</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token constant">N</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>        temp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          s <span class="token operator">+=</span> <span class="token constant">A</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>          temp<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">===</span> <span class="token constant">M</span><span class="token punctuation">)</span> res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> res<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-5-复杂度分析"><a href="#3-5-复杂度分析" class="headerlink" title="3.5 复杂度分析"></a>3.5 复杂度分析</h3><ul><li><p><font color="#f90">时间复杂度：</font></p><ul><li><code>n(num)</code> 函数用于计算一个数字在二进制表示中1的个数。它使用了<code>num &amp;= num - 1</code>这个技巧来消除最低位的1，直到<code>num</code>变为0。每次循环，<code>num</code>至少减少一个1，因此最多循环<code>num</code>中1的个数次。在最坏情况下，<code>num</code>是一个全1的二进制数，即<code>2^len - 1</code>，其中<code>len</code>是集合A的长度。因此，<code>n(num)</code>的时间复杂度是O(n)。</li><li>外层循环<code>for (let i = 1; i &lt; bit; i++)</code>遍历了所有可能的子集，其中<code>bit = 1 &lt;&lt; len</code>，即<code>2^len</code>。因此，外层循环的次数是<code>2^n</code>。</li><li>内层循环<code>for (let j = 0; j &lt; len; j++)</code>对于每个<code>i</code>，都遍历了集合A的所有元素，所以它的时间复杂度是O(n)。</li></ul><p>综上所述，总的时间复杂度是外层循环的次数乘以内层循环的次数再乘以<code>n(num)</code>的时间复杂度，即O(len * 2^len * len) = O(n^2 * 2^n)。</p></li><li><p><font color="#f90">空间复杂度：</font></p><ul><li><code>res</code>数组用于存储所有满足条件的子集，其最大长度取决于满足条件的子集数量。在最坏情况下，所有<code>2^len</code>个子集中可能有多个满足条件，因此<code>res</code>的空间复杂度可能是O(2^len)，但这取决于实际满足条件的子集数量。</li><li><code>temp</code>数组用于存储当前正在检查的子集，其长度最多为<code>len</code>，因此它的空间复杂度是O(n)。</li><li><code>n(num)</code>函数中的<code>count</code>变量和循环中的其他局部变量占用的空间是常量级的，可以忽略不计。</li></ul><p>因此，空间复杂度主要由<code>res</code>数组决定，如果考虑最坏情况，则是O(2^n)。如果考虑平均情况或实际情况（满足条件的子集数量较少），则空间复杂度可能会低于O(2^n)。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法区 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础知识</title>
      <link href="/2023/06/05/03-python-xue-xi/python-zong-bi-ji/"/>
      <url>/2023/06/05/03-python-xue-xi/python-zong-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="一、前置知识"><a href="#一、前置知识" class="headerlink" title="一、前置知识"></a>一、前置知识</h1><h2 id="1-1-Python的起源"><a href="#1-1-Python的起源" class="headerlink" title="1.1 Python的起源"></a>1.1 Python的起源</h2><ul><li>1989年，为了打发圣诞节假期，Gudio van Rossum 吉多·范罗苏姆（龟叔）觉醒开发一个新的解释程序。</li><li>1991你那，第一个Python解释器诞生。</li><li>Python这个名字，来自龟叔所致爱的电视剧<code>Monty Python's Flying Circus</code></li></ul><h2 id="1-2-为什么选择python"><a href="#1-2-为什么选择python" class="headerlink" title="1.2 为什么选择python"></a>1.2 为什么选择python</h2><table><thead><tr><th>人群</th><th>用Python做什么</th></tr></thead><tbody><tr><td>IT从业者</td><td>自动化脚本（运维开发、测试开发等）</td></tr><tr><td>普通白领</td><td>自动化办公</td></tr><tr><td>后端开发</td><td>Web引用程序</td></tr><tr><td>科学家</td><td>基于Python完成数据计算（生物、化学、物理）</td></tr><tr><td><strong>人工智能/机器学习</strong></td><td><strong>基于Python开发AI程序</strong></td></tr><tr><td><strong>大数据开发</strong></td><td><strong>基于Python完成大数据任务开发（Spark、Flink）</strong></td></tr></tbody></table><h2 id="1-2安装Python"><a href="#1-2安装Python" class="headerlink" title="1.2安装Python"></a>1.2安装Python</h2><p><a href="https://www.python.org/">python官网</a></p><p>注意事项：<font color="red">安装的时候移动要勾选下图所示的框</font></p><p><img src="/../../images/03/01%E3%80%81%E5%AE%89%E8%A3%85.png"> </p>]]></content>
      
      
      <categories>
          
          <category> 技术区 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react18源码解读</title>
      <link href="/2023/06/05/02-react-yuan-ma/react-react18/"/>
      <url>/2023/06/05/02-react-yuan-ma/react-react18/</url>
      
        <content type="html"><![CDATA[<h2 id="一、写在开头"><a href="#一、写在开头" class="headerlink" title="一、写在开头"></a>一、写在开头</h2><p>首先让我们从源头开始出发</p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx"><span class="token keyword">import</span> <span class="token punctuation">{</span> createRoot <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react-dom/client'</span><span class="token punctuation">;</span><span class="token keyword">const</span> element <span class="token operator">=</span> <span class="token punctuation">(</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">        hello&lt;span style=</span><span class="token punctuation">{</span><span class="token punctuation">{</span> color<span class="token operator">:</span> <span class="token string">'red'</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token plain-text">&gt;world</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> root <span class="token operator">=</span> <span class="token function">createRoot</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'root'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>root<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>react整体渲染过程主要用到了两个方法，即 <code>createRoot</code> 和 <code>render</code> 方法，createRoot方法主要是创建根 Fiber 与其真实DOM根节点之间的联系；而<code>render</code> 方法负责Fiber树的生成以及将Fiber树变成真实DOM树并渲染的一个过程。</p><h2 id="二、createRoot方法主要做了什么？"><a href="#二、createRoot方法主要做了什么？" class="headerlink" title="二、createRoot方法主要做了什么？"></a>二、createRoot方法主要做了什么？</h2><h3 id="2-1-大致流程"><a href="#2-1-大致流程" class="headerlink" title="2.1  大致流程"></a>2.1  大致流程</h3><ol><li>通过<code>createContainer</code> 方法创建<strong>FiberNode</strong>的一个根实例，即<font color="#f00">未初始化的根Fiber</font>。</li><li>建立 <code>FiberRootNode</code>与 <code>HostRootFiber</code>之间的联系。</li><li>初始化循环队列。</li><li>返回 <code>FiberRootNode</code>。</li></ol><blockquote><p>附上完整的实现方法</p></blockquote><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">createRoot</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 这里的root即构造函数FiberRootNode的一个实例,相当于根Fiber</span>    <span class="token comment">// FiberRootNode里面有一个containerInfo属性，this.containerInfo ==&gt; div#root</span>    <span class="token keyword">const</span> root <span class="token operator">=</span> <span class="token function">createContainer</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Fiber挂载到ReactDOMRoot的实例的一个属性_internalRoot上</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ReactDOMRoot</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">createContainer</span><span class="token punctuation">(</span>containerInfo<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">createFiberRoot</span><span class="token punctuation">(</span>containerInfo<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color="#f00">注意：下面的代码是<strong>createRoot</strong>核心做的事情</font></p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">createFiberRoot</span><span class="token punctuation">(</span>containerInfo<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// containerInfo ==&gt; div#root</span>    <span class="token keyword">const</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FiberRootNode</span><span class="token punctuation">(</span>containerInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// HostRoot指的就是根节点div#root,HostRootFiber代表根Fiber</span>    <span class="token keyword">const</span> uninitializedFiber <span class="token operator">=</span> <span class="token function">createHostRootFiber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 根容器的current指向当前的根容器(根fiber)现在正在显示或者已经渲染好的fiber树</span>    root<span class="token punctuation">.</span>current <span class="token operator">=</span> uninitializedFiber<span class="token punctuation">;</span>    <span class="token comment">// 根fiber的stateNode,也就是真实dom节点指向FiberRootNode</span>    uninitializedFiber<span class="token punctuation">.</span>stateNode <span class="token operator">=</span> root<span class="token punctuation">;</span>    <span class="token comment">// 开始初始化更新队列</span>    <span class="token function">initialUpdateQueue</span><span class="token punctuation">(</span>uninitializedFiber<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> root<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color="#08e">根Fiber大致长这个样↓</font></p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx"><span class="token comment">/** * * @param {*} tag fiber的类型 函数组件0 类组件1 原生组件5 根元素3 * @param {*} pendingProps 新属性，等待处理或者说生效的属性 * @param {*} key 唯一标识 */</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">FiberNode</span><span class="token punctuation">(</span>tag<span class="token punctuation">,</span> pendingProps<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>tag <span class="token operator">=</span> tag<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// fiber类型，来自于虚拟DOM节点的type, span div p</span>    <span class="token comment">// 每个虚拟DOM =&gt; Fiber节点 =&gt; 真实DOM</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>stateNode <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 此fiber对应的真实dom节点 h1 =&gt; 真实的h1 DOM</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>return <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 指向父节点</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>child <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 指向第一个子节点</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>sibling <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 指向next弟弟节点</span>    <span class="token comment">// fiber哪来的？通过虚拟DOM节点创建，虚拟DOM会提供pendingProps用来创建fiber节点的属性</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>pendingProps <span class="token operator">=</span> pendingProps<span class="token punctuation">;</span> <span class="token comment">// 等待生效的属性</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>memoizedProps <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 已经生效的属性</span>    <span class="token comment">// 每个fiber还会有自己的状态，每一种fiber状态的类型是不一样的</span>    <span class="token comment">// 类组件对应的fiber存的就是类的实例的状态，HostRoot存的就是要渲染的元素</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>memoizedState <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token comment">// 每个fiber身上可能还有更新队列</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>undateQueue <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token comment">// 自身副作用的标识，表示要针对此fiber节点的进行何种操作</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>flags <span class="token operator">=</span> NoFlags<span class="token punctuation">;</span> <span class="token comment">// 自己的副作用</span>    <span class="token comment">// 子节点对应的副作用使用标识，主要是为了提升性能(eg:如果副作用标识是0，那么后面的子节点就不用递归计算了)</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>subtreeFlags <span class="token operator">=</span> NoFlags<span class="token punctuation">;</span>    <span class="token comment">// 替身(相当于使用了双缓存技术或者说是预加载技术)</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>alternate <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token comment">// 默认索引值</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">createFiber</span><span class="token punctuation">(</span>tag<span class="token punctuation">,</span> pendingProps<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FiberNode</span><span class="token punctuation">(</span>tag<span class="token punctuation">,</span> pendingProps<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">createHostRootFiber</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">createFiber</span><span class="token punctuation">(</span>HostRoot<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以下是初始化循环队列的方法</p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">initialUpdateQueue</span><span class="token punctuation">(</span>fiber<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 创建一个新的更新队列</span>    <span class="token comment">// pending其实是一个循环链表</span>    <span class="token keyword">const</span> queue <span class="token operator">=</span> <span class="token punctuation">{</span>        shared<span class="token operator">:</span> <span class="token punctuation">{</span>            pending<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    fiber<span class="token punctuation">.</span>updateQueue <span class="token operator">=</span> queue<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-图文解析"><a href="#2-2-图文解析" class="headerlink" title="2.2 图文解析"></a>2.2 图文解析</h3><p><img src="/../images/02/01%E3%80%81createFiber.jpg" alt="createfiber结构图"></p><p><img src="/../images/02/02%E3%80%81createRoot%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="createfiber细节图"></p>]]></content>
      
      
      <categories>
          
          <category> 技术区 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>序章</title>
      <link href="/2023/05/20/00-xu-zhang/hello-world/"/>
      <url>/2023/05/20/00-xu-zhang/hello-world/</url>
      
        <content type="html"><![CDATA[<h1 id="序章"><a href="#序章" class="headerlink" title="序章"></a>序章</h1><p>不知不觉从19年毕业直到现在，从事着web前端开发这块也有好几年的时间了。</p><p>在此期间大大小小的笔记也做了蛮多，</p><p>从最初用的有道笔记、到现在用到的csdn、语雀、知乎、github，</p><p>才发现自己写的东西已经不知道去哪个平台回顾了（主要是懒 ^ ^）</p><p>为此思来思去，经过这几天的折腾，终于把自己的个人网站搭建起来了；</p><p>接下来的这几个月，我会针对于自己所学的知识把大前端各个分支进行分类与整合并发布到这个网站上来。</p><p>学习与写博客是一件持之以恒的事情，</p><p>这也是不断督促自己前进的一种方式；</p><p>就让我们开始行动起来吧~</p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">document<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'here we go'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 生活区 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
